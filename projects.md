# Проекты по дискретке

## Префиксные коды

* Определение кода, префиксного кода
* Эквивалентное представление с префиксным деревом
* Взвешенные символы, длина кода
* Алгоритм Хаффмана
* Оптимальность кода Хаффмана
* (Advanced) неравенство Крафта для префиксных кодов

### Однозначно декодируемые коды

* Определение однозначно декодируемых кодов
* Неравенство Крафта-Макмиллана для однозначно декодируемых кодов

## Булевы функции и критерий Поста

* Определение булевой функции
* Выражение функции через заданное множество функций
* Определение пяти классов Поста
* Замкнутость пяти классов Поста относительно подстановки
* Критерий Поста

## ДКА

Можно со мной продолжить [мою работу](https://github.com/vartem/lean-regular-languages) с ДКА и языками, возможно, дополнить [mathlib](https://github.com/leanprover-community/mathlib/tree/master/src/computability).

* Определение эквивалентных состояний ДКА
* Построение минимального ДКА как сжатие классов эквивалентности
* Доказательство минимальности по количеству состояний
* Decidable проверка эквивалентности языков?

## Контекстно-свободные грамматики

* Определение КСГ
* Определение дерева разбора слова в КСГ, КС языка
* Алгоритм приведения грамматики в НФХ
* (Advanced) МП-автоматы, допуск слова МП-автоматом, эквивалентность КСГ

## Коды Прюфера

* Определение остовного дерева полного графа (с графами в `mathlib` пока что весьма плохо)
* Алгоритмы построения кода по дереву и дерева по коду
* Доказательство \equiv

# Проекты по алгоритмам

## Декартовы деревья

* Построение декартова дерева по списку пар
* Единственность?
* Операции split, merge
* (Advanced) Матожидание высоты

## Дерево отрезков

* Определение дерева отрезков, реализация запроса сверху
* Любой отрезок можно разбить на <= 2 * ceil(log_2(n)) отрезков

## Алгоритм Флойда

* Для построения транзитивного замыкания или APSP
* Нужно определение взвешенного графа и кратчайшего пути
